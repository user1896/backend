const express = require('express');
const mongoose = require('mongoose');
const Thing = require('./models/thing'); // Import our Mongoose model (Schema)

const app = express();
// mongodb+srv://abderazak15:<password>@cluster0.fpoa31a.mongodb.net/?retryWrites=true&w=majority
mongoose.connect('mongodb+srv://abderazak15:Magnum-4546@cluster0.fpoa31a.mongodb.net/?retryWrites=true&w=majority')
	.then(()=>{
		console.log('Successfully connected to Mongodb Atlas!')
	})
	.catch((error)=>{
		console.log('Unable to connect to Mongodb Atlas!')
		console.error(error)
	})

// A middleware that intercepts all incoming POST requests that has Content-Type "application/json" and parses there JSON body
app.use(express.json());
// without Express we will have to use the module "body-parser" in order to parse the body of a "post request" as JSON.

// CORS
app.use((req, res, next) => {
	// CORS stands for "cross-origin resource sharing"
	// This is a standard that allows us to relax default security rules that prevent HTTP calls between servers. 
	// We want two origins (ex: localhost:3000 and localhost:4200), to communicate with each other.

	// This will allow requests from all origins to access the API
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content, Accept, Content-Type, Authorization');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS');
  next();
});

// A POST route that allows the frontend to send data to the backend (ex: users put objects for sell)
app.post('/api/stuff', (req, res, next) => {
	// we recieve the data in req.body
	const thing = new Thing({
		// MongoDB provides an _id field for every document which is automatically generated by default
    title: req.body.title,
    description: req.body.description,
    imageUrl: req.body.imageUrl,
    price: req.body.price,
    userId: req.body.userId
  });
	// after receiving data we must send back a response, or the request will hang.
	thing.save().then( // the "save()" method saves the object into the data base and returns a promise
		() => {
			// sending a response when the data is created successfully
			res.status(201).json({ // 201 code is for successful resource creation.
				message: 'Post saved successfully!'
			});
		}
	).catch(
		(error) => {
			// sending a response when we have an error
			res.status(400).json({
				error: error
			});
		}
	);
});

// creating an API for when the frontend accesses the route "localhost:3000/api/stuff" to get data
app.get('/api/stuff', (req, res, next) => {
	Thing.find().then(
    (things) => {
      res.status(200).json(things); // We return two things:
			// the code 200 which means that the request has succeeded.
			// and a json object containing the things we retrieved from the database.
    }
  ).catch(
    (error) => {
      res.status(400).json({
        error: error
      });
    }
  );
	// The user accessed this route to get data from the backend, so we could have used "app.get" instead of "app.use".
});

// a "get" API route to retrieve only a specific "thing"
app.get('/api/stuff/:id', (req, res, next) => {
  Thing.findOne({
    _id: req.params.id
  }).then(
    (thing) => {
      res.status(200).json(thing);
    }
  ).catch(
    (error) => {
      res.status(404).json({
        error: error
      });
    }
  );
});

// A "get request" wants to get data from the api (ex: the API reads from the database then returns a response to the frontend)
// A "post request" wants to post something (ex: the frontend sends data and we put it in the database)

/* 
app.use("route", callback) intercepts every request that comes to that route
app.get("route", callback) intercepts only "get request"
app.post("route", callback) intercepts only "post request"

We should always put "app.post" above "app.use" in the code when they have the same route, because the server executes 
middlewares from top to bottom, so "app.use" will intercept all requests to that route.

We won't have this problem of "app.use" intercepting requests in a certain route, if this route has only "app.get" and 
"app.post" middlewares, so here both get requests and post requests get handdled properly by their respective middlewares.
*/

module.exports = app;